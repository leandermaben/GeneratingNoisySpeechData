import librosa
import numpy as np
import soundfile as sf
import torch
from timeit import default_timer as timer
from PIL import Image
import json
from normalize import norm_and_LSD as normLSD

# @Author   : Shashank Shirol
# @Date     : 01/27/2021
# @File     : better_extract.py

# Using Librosa library to extract spec and phase information from an audio.
# Using it to reconstruct the audio. Also has code for calculating Log-spectral distance.
# Code for audio→spec→sinGAN→spec→audio

def extract(filename):
    """
        Extracts spectrogram from an input audio file
        Arguments:
            filename: path of the audio file
            n_fft: length of the windowed signal after padding with zeros.
    """
    data, sr = librosa.load(filename, sr=None)
    #print(len(data))
    comp_spec = librosa.stft(data, n_fft=256)

    mag_spec, phase = librosa.magphase(comp_spec)

    phase_in_angle = np.angle(phase)
    return mag_spec, phase_in_angle, sr

def reconstruct(mag_spec, phase):
    """
        Reconstructs frames from a spectrogram and phase information.
        Arguments:
            mag_spec: Magnitude component of a spectrogram
            phase:  Phase info. of a spectrogram
    """
    temp = mag_spec * np.exp(phase * 1j)
    data_out = librosa.istft(temp)
    return data_out


# to convert the spectrogram ( an 2d-array of real numbers) to a storable form (0-255)
def scale_minmax(X, min=0.0, max=1.0):
    X_std = (X - X.min()) / (X.max() - X.min())
    X_scaled = X_std * (max - min) + min
    return X_scaled, X.min(), X.max()


# to get the original spectrogram ( an 2d-array of real numbers) from an image form (0-255)
def unscale_minmax(X, X_min, X_max, min=0.0, max=1.0):
    X = X.astype(np.float)
    X -= min
    X /= (max - min)
    X *= (X_max - X_min)
    X += X_min
    return X


def to_rgb(im, chann):  # converting the image into 3-channel for singan
    if(chann == 1):
        return im
    w, h = im.shape
    ret = np.empty((w, h, chann), dtype=np.uint8)
    ret[:, :, 0] = im
    for i in range(1, chann):
        ret[:, :, i] = ret[:, :, 0]
    return ret

def save_spec_img(filename, mag_spec, phase, sr, clean = 0, pow = 1):
    name = filename.split('.')[0]

    #storing spec on db units(log based)
    #print(mag_spec)
    mag_spec = librosa.power_to_db(mag_spec**pow)

    X, X_min, X_max = scale_minmax(mag_spec, 0, 255)
    
    # Preserve orientation of the Spectrogram: lower freq at bottom, higher at the top
    X = np.flip(X, axis = 0)

    print(X_min, X_max)
    print(X.max(), X.min())

    if(clean):
        info_dict = {}
        info_dict['min'] = str(X_min)
        info_dict['max'] = str(X_max)

        phase_dict = {}
        phase_aslist = phase.tolist()
        phase_dict['phase'] = phase_aslist
        phase_dict['rate'] = sr

        with open(name + "_phase_data.json", "w") as op:
            json.dump(phase_dict, op)
        
        with open(name + "_info_data.json", "w") as op:
            json.dump(info_dict, op)
    
    np_img = X.astype(np.uint8)
    rgb_im = to_rgb(np_img, chann=3)
    img = Image.fromarray(rgb_im)
    sav = name + ".png"
    img.save(sav)
    return

def reconstruct_from_image(filename, recon_name=None, pow = 1):
    name = filename.split('.')[0]

    if(recon_name==None):
        recon_name = name

    img = np.copy(np.asarray(Image.open(filename))).astype(np.float)  # loading image generated by singan
    print(img.shape)

    img = img[:, :, 0:3]  # dropping the 4th channel

    # converting the image into a 1-channel by taking mean across the 3-channels
    img = np.mean(img, axis=2)

    img = np.flip(img, axis=0)  #flipping the image to get the original representation

    with open(recon_name + "_info_data.json", "r") as ip:
        info_dict = json.load(ip)

    new_img = unscale_minmax(img, float(info_dict['min']), float(info_dict['max']), 0, 255)
    
    with open(recon_name + "_phase_data.json", "r") as ip:
        phase_dict = json.load(ip)
    phase = np.array(phase_dict['phase'])

    ## converting db to power for reconstruction
    spec = librosa.db_to_power(new_img)
    spec = np.power(spec, 1./pow)

    #print(spec.shape)
    #print(spec)

    startT = timer()
    data_out = reconstruct(spec, phase)
    endT = timer()
    print("Time taken to reconstruct = ", endT - startT)

    sav = name + '_recon.wav'
    sf.write(sav, data_out, phase_dict['rate'])
    return

def main():
    #file_name = "paint.wav"
    #mag_spec, phase, sr = extract(filename=file_name)
    

    #save_spec_img(file_name, mag_spec, phase, sr, clean=1)
    #files = ["start_scale=1.png", "start_scale=2.png", "start_scale=3.png", "start_scale=4.png", "start_scale=5.png"]
    """ for f in files:
        reconstruct_from_image(f, "paint") """

    files = ["start_scale=1_recon.wav", "start_scale=1_old.wav", "start_scale=2_recon.wav",
             "start_scale=2_old.wav", "start_scale=3_recon.wav", "start_scale=3_old.wav", "start_scale=4_recon.wav", "start_scale=4_old.wav", "start_scale=5_recon.wav", "start_scale=5_old.wav"]

    for f in files:
        normLSD("paint_ground_truth.wav", f)
    return

if __name__ == "__main__":
    main()
